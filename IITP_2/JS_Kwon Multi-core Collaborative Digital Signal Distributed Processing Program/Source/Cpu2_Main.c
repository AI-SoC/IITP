/**********************************************************************************************************************
 * \file Cpu2_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include <def.h>
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxAsclin_Asc.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define TIMER_INT_TIME          500                             /* Time between interrupts in ms                    */
#define SYSTEM_CLK_FREQ         100000000                       /* System clock frequency in Hz                     */

#define UART_BAUDRATE           115200                                    /* UART baud rate in bit/s                  */
#define UART_PIN_RX             IfxAsclin3_RXD_P32_2_IN                 /* UART receive port pin                    */
#define UART_PIN_TX             IfxAsclin3_TX_P15_7_OUT                 /* UART transmit port pin                   */
/* Definition of the interrupt priorities */
#define INTPRIO_ASCLIN3_RX      18
#define INTPRIO_ASCLIN3_TX      19
#define UART_RX_BUFFER_SIZE     64                                      /* Definition of the receive buffer size    */
#define UART_TX_BUFFER_SIZE     64                                      /* Definition of the transmit buffer size   */
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
extern IfxCpu_syncEvent g_cpuSyncEvent;

static IfxAsclin_Asc g_ascHandle;
static uint8 g_ascTxBuffer[UART_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
static uint8 g_ascRxBuffer[UART_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

uint8 rxdata;
sint16 num_1byte = 1;

static uint8  buf[7];
static uint16 buf_len;
extern float arr_3[MAX_ARR_SIZE + CONV_FILTER_SIZE - 1];
extern uint8 flag_dsp_finish;
extern uint8 flag_dsp_finish;
uint8 pre_flag_dsp_finish = 0;
extern uint8 flag_adc_bank;     // 0 -> arr_1 busy , 1 -> arr_2 busy
uint8 pre_flag_dsp_bank;

uint16 originArr[MAX_ARR_SIZE + CONV_FILTER_SIZE - 1] = {0};
#ifdef NO_REALTIME_UART
uint16 accumulatedArr[TEMP_BUF_SIZE] = {0};
uint16 accArrCnt = 0;
#endif

/*********************************************************************************************************************/
/*---------------------------------------------Function Prototypes---------------------------------------------------*/
/*********************************************************************************************************************/
void init_ASCLIN_UART(void);
void set_baudrate(void);
void uartWrite(uint8* str, uint16 num);
uint16 num2Str(uint16 a, uint8 buf[]);
uint16 num2Strln(uint16 a, uint8 buf[]);

/*********************************************************************************************************************/
/*---------------------------------------------Interrupt Callbacks---------------------------------------------------*/
/*********************************************************************************************************************/
__interrupt(INTPRIO_ASCLIN3_TX) __vector_table(2)
void asclin3TxISR(void)
{
    IfxAsclin_Asc_isrTransmit(&g_ascHandle);
}

__interrupt(INTPRIO_ASCLIN3_RX) __vector_table(2)
void asclin3RxISR(void)
{
    IfxAsclin_Asc_isrReceive(&g_ascHandle);
    IfxAsclin_Asc_read(&g_ascHandle, (uint8*)&rxdata, &num_1byte, TIME_INFINITE);    /* Receive data via RX  */
    IfxAsclin_Asc_write(&g_ascHandle, &rxdata, &num_1byte, TIME_INFINITE);
}

/*********************************************************************************************************************/
/*---------------------------------------------Main------------------------------------------------------------------*/
/*********************************************************************************************************************/
int core2_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    init_ASCLIN_UART();
    uint8 data_col[] = "DSP ORG\n";
    uartWrite(data_col, 8);

#ifndef NO_REALTIME_UART
    while(1)
    {
        while( pre_flag_dsp_bank == flag_adc_bank );
        pre_flag_dsp_bank = flag_adc_bank;
        while( flag_dsp_finish == 0 );
        pre_flag_dsp_finish = flag_dsp_finish;

        for(uint16 i = 0; i < MAX_ARR_SIZE-1; i++) {
            buf_len = num2Str(arr_3[i], buf);
            uartWrite(buf, buf_len);

            buf_len = num2Strln(originArr[i], buf);
            uartWrite(buf, buf_len);
        }

        // UART comm. underrun debug trap
        if( pre_flag_dsp_bank != flag_adc_bank ) {
            P10_OUT.B.P2 = 0x1;     // blue
            while(1);
        }
    }
#else
    while(1)
    {
        while( pre_flag_dsp_finish == flag_dsp_finish );
        pre_flag_dsp_finish = flag_dsp_finish;

        if( pre_flag_dsp_finish ) {   // dsp not busy
            for(uint16 i = 0; i < MAX_ARR_SIZE; i++) {
                accumulatedArr[accArrCnt] = (uint16)arr_3[i];
                arr_3[i] = 0;
                accArrCnt++;
            }
        }

        if( accArrCnt == TEMP_BUF_SIZE ) {
            for(uint16 i = 0; i < TEMP_BUF_SIZE; i++) {
                buf_len = num2Str(arr_1[i], buf);
                uartWrite(buf, buf_len);
                buf_len = num2Strln(accumulatedArr[i], buf);
                uartWrite(buf, buf_len);
            }
            while(1);
        }
    }
#endif
    return (1);
}

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes the ASCLIN UART module */
void init_ASCLIN_UART(void)
{
    (&g_ascHandle)->asclin = &MODULE_ASCLIN3;

    /* transmission flags */
    (&g_ascHandle)->rxSwFifoOverflow = FALSE;
    (&g_ascHandle)->txInProgress     = FALSE;
    /* Buffer mode */
    (&g_ascHandle)->dataBufferMode = Ifx_DataBufferMode_normal;
    (&g_ascHandle)->txTimestamp    = 0;
    (&g_ascHandle)->sendCount      = 0;
    // FIFO initializes
    (&g_ascHandle)->tx = Ifx_Fifo_init(&g_ascTxBuffer, UART_TX_BUFFER_SIZE, 1);
    (&g_ascHandle)->rx = Ifx_Fifo_init(&g_ascRxBuffer, UART_RX_BUFFER_SIZE, 1);

    // Enable ASCLIN3 MODULE
    uint16 password = SCU_WDTCPU2_CON0.B.PW ^ 0x003F;
    if (SCU_WDTCPU2_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTCPU2_CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF      ) |
                             (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF          ) |
                             (password << IFX_SCU_WDTCPU_CON0_PW_OFF    ) |
                             (SCU_WDTCPU2_CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTCPU2_CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF          ) |
                         (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF              ) |
                         (password << IFX_SCU_WDTCPU_CON0_PW_OFF        ) |
                         (SCU_WDTCPU2_CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTCPU2_CON0.B.ENDINIT == 1);

    ASCLIN3_CLC.B.DISR = 0; /* enables the module*/

    if (SCU_WDTCPU2_CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        SCU_WDTCPU2_CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF      ) |
                             (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF          ) |
                             (password << IFX_SCU_WDTCPU_CON0_PW_OFF    ) |
                             (SCU_WDTCPU2_CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTCPU2_CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF          ) |
                         (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF              ) |
                         (password << IFX_SCU_WDTCPU_CON0_PW_OFF        ) |
                         (SCU_WDTCPU2_CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (SCU_WDTCPU2_CON0.B.ENDINIT == 0);

    ASCLIN3_CSR.B.CLKSEL = IfxAsclin_ClockSource_noClock;
    while (ASCLIN3_CSR.B.CON != 0U); /* disabling the clock*/

    ASCLIN3_FRAMECON.B.MODE = IfxAsclin_FrameMode_initialise;   /* setting the module in Initialise mode*/
    uint16 prescaler = 1;
    ASCLIN3_BITCON.B.PRESCALER = prescaler - 1; /* sets the prescaler */

    ASCLIN3_CSR.B.CLKSEL = IfxAsclin_ClockSource_kernelClock;
    while (ASCLIN3_CSR.B.CON != 1U);    /* temporary set the clock source for baudrate configuration*/

    set_baudrate();

    /* disabling the clock again*/
    ASCLIN3_CSR.B.CLKSEL = IfxAsclin_ClockSource_noClock;
    while (ASCLIN3_CSR.B.CON != 0U);

    ASCLIN3_IOCR.B.LB = 0;   // no LOOPBACK /* selecting the loopback mode */
    ASCLIN3_FRAMECON.B.PEN = 0;  // no PARITY   /* setting parity enable */
    ASCLIN3_FRAMECON.B.ODD = IfxAsclin_ParityType_even; /* setting parity type (odd/even)*/
    ASCLIN3_FRAMECON.B.STOP = IfxAsclin_StopBit_1;  /* setting the stop bit */
    ASCLIN3_FRAMECON.B.MSB = IfxAsclin_ShiftDirection_lsbFirst; /* setting the shift direction */
    ASCLIN3_DATCON.B.DATLEN = IfxAsclin_DataLength_8;   /* setting the data length */
    ASCLIN3_TXFIFOCON.B.INW = IfxAsclin_TxFifoInletWidth_1; /* setting Tx FIFO inlet width */
    ASCLIN3_RXFIFOCON.B.OUTW = IfxAsclin_RxFifoOutletWidth_1;   /* setting Rx FIFO outlet width */
    ASCLIN3_FRAMECON.B.IDLE = IfxAsclin_IdleDelay_0;    /* setting idle delay */
    /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
    ASCLIN3_TXFIFOCON.B.INTLEVEL = (IfxAsclin_TxFifoInterruptLevel_0 < 15) ? IfxAsclin_TxFifoInterruptLevel_0 : 15;
    /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
    ASCLIN3_RXFIFOCON.B.INTLEVEL = (IfxAsclin_RxFifoInterruptLevel_1 < 15) ? IfxAsclin_RxFifoInterruptLevel_1 : 15;
    ASCLIN3_FRAMECON.B.MODE = IfxAsclin_FrameMode_asc;   /* selecting the frame mode*/

    // ASCLIN3 Pin Config
    P32_IOCR0.B.PC2 = 0x2;      // RX
    ASCLIN3_IOCR.B.ALTI = 0x3;
    P15_IOCR4.B.PC7 = 0x12;     // TX

    ASCLIN3_CSR.B.CLKSEL = IfxAsclin_ClockSource_kernelClock;   /* select the clock source*/
    while (ASCLIN3_CSR.B.CON != 1U);    /* temporary set the clock source for baudrate configuration*/

    ASCLIN3_FLAGSENABLE.U = 0x00000000;     /* disable all flags */
    ASCLIN3_FLAGSCLEAR.U  = 0xFFFFFFFF;     /* clear all flags */

    // ASCLIN3 RX, TX interrupt config
    SRC_ASCLIN_ASCLIN3_RX.B.SRPN = INTPRIO_ASCLIN3_RX;
    SRC_ASCLIN_ASCLIN3_RX.B.TOS  = IfxSrc_Tos_cpu2;
    SRC_ASCLIN_ASCLIN3_RX.B.CLRR = 1;
    ASCLIN3_FLAGSENABLE.B.RFLE   = 1;
    SRC_ASCLIN_ASCLIN3_RX.B.SRE  = 1;

    SRC_ASCLIN_ASCLIN3_TX.B.SRPN = INTPRIO_ASCLIN3_TX;
    SRC_ASCLIN_ASCLIN3_TX.B.TOS  = IfxSrc_Tos_cpu2;
    SRC_ASCLIN_ASCLIN3_TX.B.CLRR = 1;
    ASCLIN3_FLAGSENABLE.B.TFLE   = 1;
    SRC_ASCLIN_ASCLIN3_TX.B.SRE  = 1;

    ASCLIN3_RXFIFOCON.B.ENI   = TRUE;     // enabling Rx FIFO for recieving
    ASCLIN3_TXFIFOCON.B.ENO   = TRUE;     // enabling Tx FIFO for transmitting
    ASCLIN3_RXFIFOCON.B.FLUSH = 1;      // flushing Rx FIFO
    ASCLIN3_TXFIFOCON.B.FLUSH = 1;      // flushing Tx FIFO
}

void set_baudrate(void)
{
    float32 fOvs, f;
    uint32  d = 0, n, dBest = 1, nBest = 1;

    /* Set the PD frequency */
    float32 fpd         = IfxAsclin_getPdFrequency(&MODULE_ASCLIN3);
    uint8 oversampling  = (IfxAsclin_OversamplingFactor_16 + 1) > 4 ? (IfxAsclin_OversamplingFactor_16 + 1) : 4;
    uint8 samplepoint   = IfxAsclin_SamplePointPosition_8 > 1 ? IfxAsclin_SamplePointPosition_8 : 1;
    fOvs                = UART_BAUDRATE * oversampling;
    float32 relError    = fOvs;
    float32 limit       = 0.001 * fOvs;                     // save the error limit

    boolean terminated  = FALSE;
    float32 newRelError;
    uint32  adder_facL, adder_facH, adder_facL_min, count;

    d = (uint32)(fpd / fOvs);
    n = 1;

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);

    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
        {
            f           = (fpd * n) / (n * d + count);
            newRelError = __absf(fOvs - f);

            if (relError > (newRelError))
            {
                relError       = newRelError;
                nBest          = n;
                dBest          = (n * d + count);
                adder_facL_min = count;
            }
        }

        if (relError <= limit)
        {
            break;
        }
    }

    ASCLIN3_CSR.B.CLKSEL = IfxAsclin_ClockSource_noClock;
    while (ASCLIN3_CSR.B.CON != 0U); /* disabling the clock*/
    ASCLIN3_BRG.B.DENOMINATOR = dBest;
    ASCLIN3_BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    ASCLIN3_BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    ASCLIN3_BITCON.B.SAMPLEPOINT = samplepoint;
    ASCLIN3_BITCON.B.SM = 1;    /* Set the median filter */
    ASCLIN3_CSR.B.CLKSEL = IfxAsclin_ClockSource_kernelClock;
    while (ASCLIN3_CSR.B.CON != 1U);    /* temporary set the clock source for baudrate configuration*/
}

void uartWrite(uint8 str[], uint16 num) {
    for(uint16 i = 0; i < num; i++) {
        IfxAsclin_Asc_write(&g_ascHandle, &str[i], &num_1byte, TIME_INFINITE);
    }
}

uint16 num2Str(uint16 a, uint8 buf[]) {
    uint16 copy = a;
    uint16 length = 0;
    uint8 modRes;

    if( a == 0 ) {
        buf[0] = '0';
        buf[1] = '\t';
        return 2;
    }

    while( copy != 0 ) {
        length++;
        copy /= 10;
    }

    for(int i = 0; i < length; i++) {
        modRes = a % 10;
        a /= 10;
        buf[length - (i + 1)] = modRes + '0';
    }
    buf[length] = '\t';

    return length+1;
}

uint16 num2Strln(uint16 a, uint8 buf[]) {
    uint16 copy = a;
    uint16 length = 0;
    uint8 modRes;

    if( a == 0 ) {
        buf[0] = '0';
        buf[1] = '\n';
//        buf[2] = '\r';
        return 2;
    }

    while( copy != 0 ) {
        length++;
        copy /= 10;
    }

    for(int i = 0; i < length; i++) {
        modRes = a % 10;
        a /= 10;
        buf[length - (i + 1)] = modRes + '0';
    }
    buf[length] = '\n';
//    buf[length+1] = '\r';

    return length+1;
}
